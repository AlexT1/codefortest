package com.alexstudy.base;

/**
 * @author AlexTong
 * @ClassName BridgeMethod
 * @Description TODO()
 * @date 2018/8/13 15:32:26
 */
//public class Node<T> {
//    public T data;
//
//    public BridgeMethod(T data) { this.data = data; }
//
//    public void setData(T data) {
//        System.out.println("Node.setData");
//        this.data = data;
//    }
//}

public class MyNode extends NodeDemo<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    public static void main(String[] args){
        //Consider the following code:
        MyNode mn = new MyNode(5);
        NodeDemo n = mn;            // A raw type - compiler throws an unchecked warning
      //  n.setData("Hello");
        n.setData(10);
        Integer x = mn.data;    // Causes a ClassCastException to be thrown.
        // java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer
        System.out.println(x);
        //After type erasure, this code becomes:
//        MyNode mn = new MyNode(5);
//        Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning
//        n.setData("Hello");
//        Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.
        //Here is what happens as the code is executed:
        // n.setData("Hello"); causes the method setData(Object) to be executed on the object of class MyNode. (The MyNode class inherited setData(Object) from Node.)
        // In the body of setData(Object), the data field of the object referenced by n is assigned to a String.
        // The data field of that same object, referenced via mn, can be accessed and is expected to be an integer (since mn is a MyNode which is a Node<Integer>.
        // Trying to assign a String to an Integer causes a ClassCastException from a cast inserted at the assignment by a Java compiler.
    }
}

// after type erasure, the Node and MyNode classes become:
//public class Node {
//
//    public Object data;
//
//    public Node(Object data) { this.data = data; }
//
//    public void setData(Object data) {
//        System.out.println("Node.setData");
//        this.data = data;
//    }
//}
//
//public class MyNode extends Node {
//
//    public MyNode(Integer data) { super(data); }
//
//    public void setData(Integer data) {
//        System.out.println("MyNode.setData");
//        super.setData(data);
//    }
//}

//To solve this problem and preserve the polymorphism of generic types after type erasure, a Java compiler generates a bridge method to
// ensure that subtyping works as expected. For the MyNode class, the compiler generates the following bridge method for setData:
//class MyNode extends Node {
//
//    // Bridge method generated by the compiler
//    //
//    public void setData(Object data) {
//        setData((Integer) data);
//    }
//
//    public void setData(Integer data) {
//        System.out.println("MyNode.setData");
//        super.setData(data);
//    }
//
//    // ...
//}
// As you can see, the bridge method, which has the same method signature as the Node class's setData method after type erasure,
// delegates to the original setData method.